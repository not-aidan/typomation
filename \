use interpolation::*;
use std::time::Duration;

use bevy::prelude::*;

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_system(transform_track_system)
        .run();
}

type Scalar = f32;

#[derive(Component)]
struct TransformTrack {
    x: Track<Scalar>,
    y: Track<Scalar>,
    z: Track<Scalar>,
}

struct Key<T: Ease> {
    value: T,
    duration: Duration,
    ease: EaseFunction,
}

struct Track<T: Ease> {
    keys: Vec<Key<T>>,
}

impl<T: Ease> Track<T> {
    fn value(&self, mut duration: Duration) -> Option<&T> {
        let mut value: Option<&T> = None;
        for key in self.keys.iter() {
            if duration > key.duration {
                duration -= key.duration;
                value = Some(&key.value);
            }
        }
        value
    }
}

fn transform_track_system(mut query: Query<(&mut Transform, &TransformTrack)>) {
    for (mut transform, track) in query.iter_mut() {}
}
